def solution(places):
    answer = []
    p자리 뽑기
    count2 까지 이동
    
    return answer

def move(pos,move):
    for i in move:
        if places[pos[0]+i[0]][pos[1]+i[1]] == "X":
            return
        elif places[pos[0]+i[0]][pos[1]+i[1]] == "P":
            return

################################################################################################################

from itertools import combinations


def solution(places):
    up = (1,0)
    down = [-1,0]
    right = (0,1)
    left = (0,-1)
    direction = [up,down,right,left]
    
    
    pposition = []
    for k in places:
        temp = []
        for i in range(5):
            for j in range(5):
                if k[i][j] == "P":
                    temp.append([i,j])
                    
        pposition.append(temp)    
#     print(pposition)
    check = []
    for i in pposition:
        temp = []
        for j in range(len(i)):
            for k in range(len(i)):
                if j == k:
                    continue
                if (abs(i[j][0]-i[k][0]) + abs(i[j][1]-i[k][1])) <= 2:
                    temp.append([i[j][0],i[j][1]])
                    break
        check.append(temp)
    print(pposition,"검사부",check)
                
    
    
#     for i in range(len(places)):
#         for j in pposition[i]:
#             for k in direction:
#                 places[i][j[0]][j[1]]
    
#     for i in direction:
        
    
    
    answer = []
    
    return answer

# def move(pos,move):
#     for i in move:
#         if places[pos[0]+i[0]][pos[1]+i[1]] == "X":
#             return
#         elif places[pos[0]+i[0]][pos[1]+i[1]] == "P":
#             return
######### 검토가 필요한 P위치 판별 

def solution(places):
    answer = [1] * len(places)

    pposition = []
    for k in places:
        temp = []
        for i in range(5):
            for j in range(5):
                if k[i][j] == "P":
                    temp.append([i, j])

        pposition.append(temp)

    check = []

    for i in range(len(pposition)):
        temp = []
        for j in pposition[i]:
            for k in pposition[i]:
                if abs(j[0] - k[0]) + abs(j[1] - k[1]) == 1:
                    answer[i] = 0
                if abs(j[0] - k[0]) + abs(j[1] - k[1]) == 2:
                    temp.append(j)
                    break
        check.append(temp)

    for i in range(len(check)):
        for j in check[i]:

            if answer[i] == 0:
                break

            if not j[1] == 0:
                if places[i][j[0]][j[1] - 1] == "X":
                    pass
                elif j[0] + 1 <= 4 and places[i][j[0] + 1][j[1] - 1] == "P":
                    answer[i] = 0
                    print("case1")
                    break
            if not j[1] == len(places[i][1])-1:
                if places[i][j[0]][j[1] + 1] == "X":
                    pass
                elif j[0] + 1 <= 4 and places[i][j[0] + 1][j[1] + 1] == "P":
                    answer[i] = 0
                    print("case2")
                    break
                elif j[1] + 2 <= 4 and places[i][j[0]][j[1] + 2] == "P":
                    answer[i] = 0
                    print("case2")
                    break

            if not j[0] == len(places[i])-1:
                if places[i][j[0] + 1][j[1]] == "X":
                    pass
                elif j[1] + 1 <= 4 and places[i][j[0] + 1][j[1] + 1] == "P":
                    answer[i] = 0
                    print("case3")
                    break
                elif j[1] - 1 >= 0 and places[i][j[0] + 1][j[1] - 1] == "P":
                    answer[i] = 0
                    print("case4")
                    break
                elif j[0] + 2 <= 4 and places[i][j[0] + 2][j[1]] == "P":
                    answer[i] = 0
                    print("case5")
                    break

    return answer
    
    ############### 케이스3번 탈락 96점

def solution(places):
    
    answer = [1] * len(places)

    for i in range(len(places)):
        count = 0
        for j in range(len(places)):
            for k in range(5):

                if places[i][j][k] == "O" :

                    if k >= 1 and places[i][j][k-1] == "P":
                        count += 1
                    if k <= 3 and places[i][j][k+1] == "P":
                        count += 1
                    if j >= 1 and places[i][j-1][k] == "P":
                        count += 1
                    if j <= 3 and places[i][j+1][k] == "P":
                        count += 1
                
                    if count >= 2:
                        answer[i] = 0
                        break

                        
                if places[i][j] == "P" :
                    if i >= 1 and places[i-1][j] == "P":
                        answer[i] = 0
                        break
                    if i <= 3 and places[i+1][j] == "P":
                        answer[i] = 0
                        break
                    if j >= 1 and places[i][j-1] == "P":
                        answer[i] = 0
                        break
                    if j <= 3 and places[i][j+1] == "P":
                        answer[i] = 0
                        break
                
    
    return answer 
    
    ############# 0 주위 p가 2개면 지키지않음 + pp 검출
